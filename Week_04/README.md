- 学号：G20200579010556
- 姓名：刘流流
- 班级：4 班



# 习题

**1.（选做）**把示例代码，运行一遍，思考课上相关的问题。也可以做一些比较。



**2.（必做）**思考有多少种方式，在 main 函数启动一个新线程，运行一个方法，拿到这个方法的返回值后，退出主线程？写出你的方法，越多越好，提交到 Github。

代码请参看 Homework03.java



**3.（选做）**列举常用的并发操作 API 和工具类，简单分析其使用场景和优缺点。

CountDownLatch: 用于主线程等待一组线程执行完毕；

CycliaBarrier: 用于一组线程重复执行任务，但每一轮要一起开始；

Semaphore: 可用于限流，但限流有非常强大的框架，比如guava中的令牌桶，漏桶，分布式限流框架sentinel等；

CompletableFuture: 可用于组合异步操作；



**4.（选做）**请思考：什么是并发？什么是高并发？实现高并发高可用系统需要考虑哪些因素，对于这些你是怎么理解的？

并行与并发： 并行指多个互不影响的任务一起执行；并发指多个线程协作执行共同完成任务；
高并发：



**5.（选做）**请思考：还有哪些跟并发类似 / 有关的场景和问题，有哪些可以借鉴的解决办法。



**6.（必做）**把多线程和并发相关知识带你梳理一遍，画一个脑图，截图上传到 Github 上。

![](https://gitee.com/pismery/imageshack/raw/master/img/20201110214431.png)







三类问题

1. 确定问题
2. 两难问题: CAP
3. 棘手问题



#### newSingleThreadExecutor

线程池只有一个线程，任务按加入顺序执行，如果中间任务出现异常，线程池会新建线程继续执行后续任务；

适用于场景示例:

在一个 api 中，程序的最后要调用一个耗时长的存储过程，且程序不关心存储过程的执行结果。所以启动新线程调用储存过程 ，主线程直接返回结果。但是由于储存过程执行的时间很长，多用户访问的时候，容易出现多个线程调用存储过程，如果他们操作了同一张表的同一条数据， 就容易导致死锁。所以我们希望调用存储过程的线程一次只有一个线程执行。这个时候就可以用只有一个线程的线程池。